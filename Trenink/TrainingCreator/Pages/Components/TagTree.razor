@using TrainingDataAccess.Models
@using TrainingCreator.Data
@using TrainingCreator.Shared
@using TrainingDataAccess.Dtos

<MudPaper Elevation="0">
    <MudList Clickable="@true" Dense="@true">
            <MudListSubheader>
                <MudTextField @bind-Value="@SearchTerm" Variant="@Variant.Text" Adornment="@Adornment.Start"
                              AdornmentIcon="@Icons.Material.Filled.Search" HelperText="Hledej"/>
            </MudListSubheader>

            @foreach (var tag in GetFilteredItems())
            {
                <CascadingValue Value="this">
                    <CascadingValue Value="@SelectedValues">
                        <TagItem Tag="@tag"/>
                    </CascadingValue>
                </CascadingValue>
            }
        </MudList>
</MudPaper>

@code {

    [Parameter]
    public List<TagDto> Tags { get; set; } = new();

    [Parameter]
    public List<int> SelectedValues { get; set; } = new List<int>();

    [CascadingParameter]
    public TagsList Parent { get; set; } = null!;


    public void Refresh()
    {
        //StateHasChanged();
        Parent.Refresh(SelectedValues);
    }

    private string SearchTerm { get; set; } = "";

    private List<TagDto> _backupOriginalTags = new List<TagDto>();

    protected override async Task OnParametersSetAsync()
    {
       
        _backupOriginalTags = Tags.Select(tag => new TagDto(tag)).ToList();
        GetFilteredItems();
        await base.OnParametersSetAsync();
    }

    private List<TagDto> GetFilteredItems()
    {
        if (string.IsNullOrEmpty(SearchTerm))
        {
            return _backupOriginalTags.Where(t => t.ParentTagId == null).ToList();
        }

        var foundTags = _backupOriginalTags.Where(x => x.Name != null && x.Name.Contains(SearchTerm, StringComparison.InvariantCultureIgnoreCase)).Select(t => new TagDto(t)).ToList();
        var result =BuildTree(foundTags);

        return result.OrderBy(r=>r.Name).ToList();
    }

    private List<TagDto> BuildTree(List<TagDto> tags)
    {
        if (!tags.Any()) return new List<TagDto>();
        var result = new List<TagDto>();

        var maxLevel = tags.Max(t => t.Level);

        foreach (var tag in tags.Where(t => t.Level <= maxLevel))
        {
            if (!tag.IsRoot)
            {
                var parent = tag.ParentTag;

                if (parent == null)
                {
                    throw new Exception("Parent tag is null");
                }

                var children = tags.Where(t => t.ParentTagId == parent.TagId).ToList();

                parent.Children = children;

                if (!result.Contains(parent)) result.Add(parent);

                result = BuildTree(result);
            }
            else
            {
                if (result.All(t => t.TagId != tag.TagId)) result.Add(tag);
            }
        }

        return result;

    

    
    

}

}
