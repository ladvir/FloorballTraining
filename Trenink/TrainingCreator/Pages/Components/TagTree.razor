@using TrainingDataAccess.Models
@using TrainingCreator.Data
<MudPaper MinWidth="300px" MaxWidth="20%" MinHeight="500px" MaxHeight="80%" Class="overflow-y-auto" Elevation="0">

    <MudList Clickable="true" Dense="true">
        <MudListSubheader>
            <MudTextField @bind-Value="@SearchTerm" Variant="Variant.Text" Adornment="Adornment.Start" AdornmentIcon="@Icons.Material.Filled.Search" HelperText="Hledej" />
            
            <MudText T="long">@_recordsCount</MudText>
        </MudListSubheader>
        

        @foreach (var tag in GetFilteredItems())
        {
            <TagItem Tag="@tag" />
        }
    </MudList>
</MudPaper>

@code {

    [Parameter]
    public ICollection<Tag> Tags { get; set; } = null!;

    private string SearchTerm { get; set; } = "";

    private long _recordsCount;


    private List<Tag> _backupOriginalTags = new List<Tag>();

    protected override Task OnInitializedAsync()
    {
        _backupOriginalTags = Tags.Select(tag => new Tag(tag)).ToList();

        GetFilteredItems();
        return base.OnInitializedAsync();

    }

    private List<Tag> GetFilteredItems()
    {
        if (string.IsNullOrEmpty(SearchTerm))
        {
            return _backupOriginalTags.Where(t => t.ParentTagId == null).ToList();
        }

        var foundTags = _backupOriginalTags.Where(x => x.Name != null && x.Name.Contains(SearchTerm, StringComparison.InvariantCultureIgnoreCase)).Select(t => new Tag(t)).ToList();
        var result =BuildTree(foundTags);

        return result.OrderBy(r=>r.Name).ToList();
    }
    
    private List<Tag> BuildTree(List<Tag> tags)
    {
        if (!tags.Any()) return new List<Tag>();
        var result = new List<Tag>();

        var maxLevel = tags.Max(t => t.Level);

        foreach (var tag in tags.Where(t => t.Level <= maxLevel))
        {
            if (!tag.IsRoot)
            {
                var parent = tag.ParentTag!;

                var children = tags.Where(t => t.ParentTagId == parent.TagId).ToList();

                parent.Children = children;

                if (!result.Contains(parent)) result.Add(parent);

                result = BuildTree(result);
            }
            else
            {
                if (result.All(t => t.TagId != tag.TagId)) result.Add(tag);
            }
        }

        return result;

    }
}
