<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVG Drawing App (Rotation Fix Attempt)</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
<h1>SVG Drawing App (Rotation Fix Attempt)</h1>
<!-- HTML -->
<div id="container"> <div class="sidebar" id="activity-list"> <h3>Activities</h3> </div> <div id="drawing-area"> <svg id="svg-canvas"></svg> </div> <div class="sidebar" id="svg-library"> <h3>SVG Library</h3> <div style="text-align: center; margin-bottom: 10px;"> <button id="add-svg-btn" style="width: 90%;">Add SVG to Library</button> </div> </div> </div> <div class="controls"> <button id="select-tool" data-tool="select">Select Tool</button> <button id="resize-tool" data-tool="resize">Resize Tool</button> <button id="delete-tool" data-tool="delete">Delete Tool</button> <button id="save-button">Save</button> <button id="load-button">Load</button> <button id="export-svg">Export</button> <button id="import-svg">Import</button> <input type="file" class="file-input" id="file-input" accept=".svg" /> <input type="file" class="file-input" id="library-input" accept=".svg" multiple /> </div>

<script>
    (function() {
        // Constants and appState setup (as before)
        const SVG_NS = "http://www.w3.org/2000/svg";
        const MIN_ELEMENT_WIDTH = 40;
        const MIN_ELEMENT_HEIGHT = 40;
        const MOVE_HANDLE_HEIGHT = 4;
        const MOVE_HANDLE_OFFSET = 2;
        const MOVE_HANDLE_WIDTH_PERCENT = 0.2;
        const RESIZE_HANDLE_OFFSET = 3;
        const RESIZE_HANDLE_RADIUS = 5;
        const ROTATE_HANDLE_RADIUS = 6;
        const ROTATION_STEP = 30;

        const appState = { /* state... */
            currentTool: 'select', selectedElement: null, isDragging: false, isResizing: false,
            dragOffsetX: 0, dragOffsetY: 0,
            actionStartPoint: { x: 0, y: 0 }, elementStartPos: { x: 0, y: 0}, elementStartSize: { width: 0, height: 0},
            svgLibrary: JSON.parse(localStorage.getItem("svgLibrary") || "[]"),
            activities: [ /* activities data... */
                { id: 1, name: "Activity A", svg: "<circle cx='20' cy='20' r='18' fill='blue' class='activity-svg' />" },
                { id: 2, name: "Activity B", svg: "<rect x='5' y='5' width='30' height='30' fill='red' class='activity-svg' />" },
                { id: 3, name: "Activity C", svg: "<svg class='activity-svg' viewBox='0 0 40 40' width='40' height='40'><path fill='#555' d='M20 1.6c-3.46 0-6.24 2.78-6.24 6.24s2.78 6.24 6.24 6.24 6.24-2.78 6.24-6.24S23.46 1.6 20 1.6zm-7.68 14.24c-3.46 0-6.24 2.78-6.24 6.24s2.78 6.24 6.24 6.24 6.24-2.78 6.24-6.24-2.78-6.24-6.24-6.24zm15.36 0c-3.46 0-6.24 2.78-6.24 6.24s2.78 6.24 6.24 6.24 6.24-2.78 6.24-6.24-2.78-6.24-6.24-6.24zm-23.04 14.4c-3.46 0-6.24 2.78-6.24 6.24s2.78 6.24 6.24 6.24 6.24-2.78 6.24-6.24-2.78-6.24-6.24-6.24zm15.36 0c-3.46 0-6.24 2.78-6.24 6.24s2.78 6.24 6.24 6.24 6.24-2.78 6.24-6.24-2.78-6.24-6.24-6.24zm15.36 0c-3.46 0-6.24 2.78-6.24 6.24s2.78 6.24 6.24 6.24 6.24-2.78 6.24-6.24-2.78-6.24-6.24-6.24z'/></svg>" }
            ],
        };

        const dom = { /* dom refs... */
            activityList: document.getElementById("activity-list"), svgCanvas: document.getElementById("svg-canvas"), svgLibraryList: document.getElementById("svg-library"), addSvgBtn: document.getElementById("add-svg-btn"), libraryInput: document.getElementById("library-input"), toolButtons: document.querySelectorAll(".controls button[data-tool]"), saveButton: document.getElementById("save-button"), loadButton: document.getElementById("load-button"), exportSvgButton: document.getElementById("export-svg"), importSvgButton: document.getElementById("import-svg"), fileInput: document.getElementById("file-input"),
        };

        // --- Core Functions ---
        // MODIFIED: setActiveTool manages body classes for cursor control
        function setActiveTool(toolName) {
            // Remove previous tool classes from body
            document.body.classList.remove('tool-select', 'tool-resize', 'tool-delete');
            // Add current tool class
            if (toolName) {
                document.body.classList.add(`tool-${toolName}`);
            }

            appState.currentTool = toolName;
            // Update button styles
            dom.toolButtons.forEach(button => {
                button.classList.toggle('active-tool', button.dataset.tool === toolName);
            });
            // Global canvas/element cursor updates are now handled by CSS via body class
        }

        // (clearSelection, selectElement, updateSelectionOutline - No changes needed)
        function clearSelection() { if (appState.selectedElement) { appState.selectedElement.classList.remove('selected'); appState.selectedElement.querySelector('.selected-outline')?.remove(); appState.selectedElement = null; } } // Simplified cursor reset as CSS handles it now
        function selectElement(element) { if (appState.selectedElement === element) return; clearSelection(); appState.selectedElement = element; element.classList.add('selected'); updateSelectionOutline(element); /* No need to call setActiveTool just for cursor update */ }
        function updateSelectionOutline(element) { if (!element) return; let outline = element.querySelector('.selected-outline'); if (!outline) { outline = document.createElementNS(SVG_NS, 'rect'); outline.setAttribute('class', 'selected-outline'); const firstHandle = element.querySelector('.move-handle') || element.querySelector('.rotate-handle') || element.querySelector('.resize-handle'); if (firstHandle) { element.insertBefore(outline, firstHandle); } else { element.appendChild(outline); } } const bgRect = element.querySelector('.element-bg'); if (!bgRect) return; const width = parseFloat(bgRect.getAttribute('width') || '0'); const height = parseFloat(bgRect.getAttribute('height') || '0'); const padding = 2; outline.setAttribute('x', String(-padding)); outline.setAttribute('y', String(-padding)); outline.setAttribute('width', String(width + 2 * padding)); outline.setAttribute('height', String(height + 2 * padding)); outline.setAttribute('rx', '5'); outline.setAttribute('ry', '5'); }

        // --- SVG Library & Activity List Management ---
        // (No changes needed)
        function loadSvgLibrary() { dom.svgLibraryList.querySelectorAll('.library-item').forEach(item => item.remove()); if (!Array.isArray(appState.svgLibrary)) { console.error("SVG Library data is not an array. Resetting."); appState.svgLibrary = []; localStorage.setItem("svgLibrary", "[]"); } appState.svgLibrary.forEach((svgItem, index) => { if (svgItem && typeof svgItem.name === 'string' && typeof svgItem.content === 'string') { addSvgToLibraryUI(svgItem.name, svgItem.content, index); } else { console.warn(`Skipping invalid SVG library item at index ${index}:`, svgItem); } }); }
        function addSvgToLibraryUI(name, svgContent, index) { const item = document.createElement("div"); item.className = "sidebar-item-base library-item"; item.draggable = true; item.dataset.svgContent = svgContent; item.dataset.svgName = name || `SVG ${index + 1}`; const svgPreview = document.createElement("div"); try { svgPreview.innerHTML = svgContent; } catch (e) { console.error("Error parsing SVG for preview:", name, e); svgPreview.textContent = "[Invalid SVG]"; } const svgElement = svgPreview.querySelector('svg'); if (svgElement) { svgElement.setAttribute('preserveAspectRatio', 'xMidYMid meet'); svgElement.removeAttribute('width'); svgElement.removeAttribute('height'); svgElement.style.display = 'block'; } else { svgPreview.textContent = "[SVG Preview Error]"; } item.appendChild(svgPreview); const nameSpan = document.createElement("span"); nameSpan.className = "item-name"; nameSpan.textContent = item.dataset.svgName; item.appendChild(nameSpan); const deleteBtn = document.createElement("button"); deleteBtn.className = "delete-btn"; deleteBtn.textContent = "Remove"; deleteBtn.onclick = (e) => { e.stopPropagation(); appState.svgLibrary.splice(index, 1); localStorage.setItem("svgLibrary", JSON.stringify(appState.svgLibrary)); loadSvgLibrary(); }; item.appendChild(deleteBtn); item.addEventListener("dragstart", handleLibraryDragStart); dom.svgLibraryList.appendChild(item); }
        function handleLibraryFileRead(file) { const reader = new FileReader(); reader.onload = function(e) { try { const parser = new DOMParser(); const svgDoc = parser.parseFromString(e.target.result, "image/svg+xml"); const parseError = svgDoc.querySelector('parsererror'); if (!svgDoc.documentElement || svgDoc.documentElement.nodeName !== "svg" || parseError) { throw new Error(`File ${file.name} is not a valid SVG.${parseError ? ' ' + parseError.textContent : ''}`); } const svgElement = svgDoc.documentElement; svgElement.removeAttribute('id'); const svgContent = svgElement.outerHTML; appState.svgLibrary.push({ name: file.name.replace('.svg', ''), content: svgContent }); localStorage.setItem("svgLibrary", JSON.stringify(appState.svgLibrary)); loadSvgLibrary(); } catch (error) { console.error("Error processing library SVG:", error); alert(`Could not add ${file.name}: ${error.message}`); } }; reader.onerror = () => alert(`Error reading file: ${file.name}`); reader.readAsText(file); }
        function loadActivities() { dom.activityList.querySelectorAll('.activity-item').forEach(item => item.remove()); appState.activities.forEach(activity => { const item = document.createElement("div"); item.className = "sidebar-item-base activity-item"; item.textContent = activity.name; item.draggable = true; item.dataset.activityId = String(activity.id); item.addEventListener("dragstart", handleActivityDragStart); dom.activityList.appendChild(item); }); }

        // --- Canvas Element Creation ---
        // (No changes needed)
        function createCanvasElement(config, x, y) { config = config || {}; config.width = Math.max(MIN_ELEMENT_WIDTH, config.width || MIN_ELEMENT_WIDTH); config.height = Math.max(MIN_ELEMENT_HEIGHT, config.height || MIN_ELEMENT_HEIGHT); config.name = config.name || "Element"; const group = document.createElementNS(SVG_NS, "g"); group.classList.add("canvas-element"); const initialTranslateX = x - config.width / 2; const initialTranslateY = y - config.height / 2; group.setAttribute("transform", `translate(${initialTranslateX}, ${initialTranslateY})`); group.dataset.rotation = "0"; if (config.id) group.dataset.activityId = String(config.id); if (config.name) group.dataset.elementName = config.name; const rect = document.createElementNS(SVG_NS, "rect"); rect.setAttribute("class", "element-bg"); rect.setAttribute("x", "0"); rect.setAttribute("y", "0"); rect.setAttribute("width", String(config.width)); rect.setAttribute("height", String(config.height)); rect.setAttribute("rx", "10"); rect.setAttribute("ry", "10"); rect.setAttribute("fill", "lightyellow"); rect.setAttribute("stroke", "black"); group.appendChild(rect); const text = document.createElementNS(SVG_NS, "text"); text.setAttribute("x", "10"); text.setAttribute("y", "20"); text.setAttribute("font-size", "12"); text.setAttribute("fill", "black"); text.setAttribute("class", "element-label"); text.style.pointerEvents = "none"; text.textContent = config.name; group.appendChild(text); const contentPaddingX = 10; const contentPaddingY = 30; const contentWidth = Math.max(0, config.width - 2 * contentPaddingX); const contentHeight = Math.max(0, config.height - contentPaddingY - 10); if (config.type === 'activity' && config.svgContent) { const svgContainer = document.createElementNS(SVG_NS, "svg"); svgContainer.setAttribute("x", String(contentPaddingX)); svgContainer.setAttribute("y", String(contentPaddingY)); svgContainer.setAttribute("width", String(contentWidth)); svgContainer.setAttribute("height", String(contentHeight)); svgContainer.setAttribute("preserveAspectRatio", "xMidYMid meet"); svgContainer.setAttribute("viewBox", "0 0 40 40"); try { svgContainer.innerHTML = config.svgContent; } catch (e) { console.error("Error setting innerHTML for activity SVG:", e); } svgContainer.style.pointerEvents = "none"; group.appendChild(svgContainer); } else if (config.type === 'library' && config.svgContent) { const foreignObject = document.createElementNS(SVG_NS, "foreignObject"); foreignObject.setAttribute("x", String(contentPaddingX)); foreignObject.setAttribute("y", String(contentPaddingY)); foreignObject.setAttribute("width", String(contentWidth)); foreignObject.setAttribute("height", String(contentHeight)); try { foreignObject.innerHTML = `<div xmlns="http://www.w3.org/1999/xhtml" style="width:100%; height:100%; overflow:hidden;">${config.svgContent}</div>`; const innerSvg = foreignObject.querySelector('svg'); if (innerSvg) { innerSvg.style.width = '100%'; innerSvg.style.height = '100%'; innerSvg.style.display = 'block'; innerSvg.setAttribute('preserveAspectRatio', 'xMidYMid meet'); } } catch (e) { console.error("Error setting innerHTML for library SVG:", e); } foreignObject.style.pointerEvents = "none"; group.appendChild(foreignObject); } ensureHandles(group, config.width, config.height); dom.svgCanvas.appendChild(group); makeElementInteractive(group); }

        // --- Interactivity ---
        // (makeElementInteractive, handleElementClick - No changes needed)
        function makeElementInteractive(element) { if (!element) return; element.removeEventListener("mousedown", handleElementMouseDown); element.removeEventListener("click", handleElementClick); element.addEventListener("mousedown", handleElementMouseDown); element.addEventListener("click", handleElementClick); /* setActiveTool(appState.currentTool); // Initial cursor now set by CSS */ }
        function handleElementClick(event) { const element = event.currentTarget; if (appState.isDragging || appState.isResizing) { return; } const targetClasses = event.target.classList; if (appState.currentTool === 'delete' && !targetClasses.contains('resize-handle') && !targetClasses.contains('move-handle') && !targetClasses.contains('rotate-handle')) { clearSelection(); element.remove(); } else if (!targetClasses.contains('resize-handle') && !targetClasses.contains('move-handle') && !targetClasses.contains('rotate-handle')) { selectElement(element); } event.stopPropagation(); }

        // (getOrAddTransform helper - No changes needed)
        function getOrAddTransform(transformList, type, initialValueX = 0, initialValueY = 0) { let transform = null; let index = -1; for (let i = 0; i < transformList.numberOfItems; i++) { if (transformList.getItem(i).type === type) { transform = transformList.getItem(i); index = i; break; } } if (!transform) { transform = dom.svgCanvas.createSVGTransform(); if (type === SVGTransform.SVG_TRANSFORM_TRANSLATE) { transform.setTranslate(initialValueX, initialValueY); transformList.insertItemBefore(transform, 0); index = 0; console.warn("Created and prepended missing TRANSLATE transform."); } else if (type === SVGTransform.SVG_TRANSFORM_ROTATE) { transform.setRotate(0, initialValueX, initialValueY); transformList.appendItem(transform); index = transformList.numberOfItems - 1; console.warn("Created and appended missing ROTATE transform."); } else { transformList.appendItem(transform); index = transformList.numberOfItems - 1; console.warn(`Created and appended missing transform of type ${type}.`); } } return transform; }

        // MODIFIED: handleElementMouseDown - Simplified logic, only react to handle clicks
        function handleElementMouseDown(event) {
            const element = event.currentTarget;
            const targetClasses = event.target.classList;

            // --- IMPORTANT: Only proceed if clicking a handle ---
            if (!targetClasses.contains('move-handle') &&
                !targetClasses.contains('rotate-handle') &&
                !targetClasses.contains('resize-handle')) {
                // If clicking the body, just ensure it's selected (if select tool) or deleted (if delete tool)
                if (appState.currentTool === 'select') {
                    selectElement(element); // Select if not already selected
                } else if (appState.currentTool === 'delete'){
                    // Delete is handled in handleElementClick to avoid accidental deletes on drag start attempt
                }
                // Don't prevent default or stop propagation if just selecting body
                // Allow potential canvas click listener to clear selection if needed.
                return;
            }

            // --- If clicking a handle, prevent default browser actions ---
            event.preventDefault();
            event.stopPropagation();

            const startPoint = svgPoint(dom.svgCanvas, event.clientX, event.clientY);
            if (!startPoint) return;

            selectElement(element); // Ensure element is selected when interacting with handles
            if (!appState.selectedElement) return;

            const transformList = element.transform.baseVal;

            // --- Rotation Logic ---
            if (targetClasses.contains('rotate-handle')) {
                appState.isDragging = false; appState.isResizing = false;
                const rect = element.querySelector(".element-bg");
                if (!rect) { console.error("Rotation failed: .element-bg not found"); return; }
                const width = parseFloat(rect.getAttribute("width") || "0");
                const height = parseFloat(rect.getAttribute("height") || "0");
                if (width <= 0 || height <= 0) return;
                const centerX = width / 2;
                const centerY = height / 2;
                const currentRotation = parseFloat(element.dataset.rotation || "0");
                const newRotation = (currentRotation + ROTATION_STEP);
                const rotateTransform = getOrAddTransform(transformList, SVGTransform.SVG_TRANSFORM_ROTATE, centerX, centerY);
                rotateTransform.setRotate(newRotation, centerX, centerY);
                element.dataset.rotation = String(newRotation);
            }
            // --- Move Logic ---
            else if (targetClasses.contains('move-handle')) {
                appState.isDragging = true; appState.isResizing = false;
                const initialTranslate = getOrAddTransform(transformList, SVGTransform.SVG_TRANSFORM_TRANSLATE);
                appState.dragOffsetX = startPoint.x - initialTranslate.matrix.e;
                appState.dragOffsetY = startPoint.y - initialTranslate.matrix.f;
                document.addEventListener('mousemove', handleDocumentMouseMove, false);
                document.addEventListener('mouseup', handleDocumentMouseUp, false);
            }
            // --- Resize Logic ---
            else if (targetClasses.contains('resize-handle') && appState.currentTool === 'resize') {
                appState.isResizing = true; appState.isDragging = false;
                const initialTranslate = getOrAddTransform(transformList, SVGTransform.SVG_TRANSFORM_TRANSLATE);
                const rect = element.querySelector(".element-bg");
                if (!rect) { appState.isResizing = false; return; }
                appState.actionStartPoint = startPoint;
                appState.elementStartPos = { x: initialTranslate.matrix.e, y: initialTranslate.matrix.f };
                appState.elementStartSize = { width: parseFloat(rect.getAttribute("width") || '0'), height: parseFloat(rect.getAttribute("height") || '0') };
                document.addEventListener('mousemove', handleDocumentMouseMove, false);
                document.addEventListener('mouseup', handleDocumentMouseUp, false);
            }
            // No else - only handles initiate drag/resize/rotate
        }

        // (handleDocumentMouseMove - No changes needed from previous version)
        function handleDocumentMouseMove(event) { if (!appState.selectedElement || (!appState.isDragging && !appState.isResizing)) { return; } const currentPoint = svgPoint(dom.svgCanvas, event.clientX, event.clientY); if (!currentPoint) return; const element = appState.selectedElement; const transformList = element.transform.baseVal; if (appState.isDragging) { const translateTransform = getOrAddTransform(transformList, SVGTransform.SVG_TRANSFORM_TRANSLATE); const newTranslateX = currentPoint.x - appState.dragOffsetX; const newTranslateY = currentPoint.y - appState.dragOffsetY; translateTransform.setTranslate(newTranslateX, newTranslateY); } else if (appState.isResizing && appState.currentTool === 'resize') { const translateTransform = getOrAddTransform(transformList, SVGTransform.SVG_TRANSFORM_TRANSLATE, appState.elementStartPos.x, appState.elementStartPos.y); const deltaX = currentPoint.x - appState.actionStartPoint.x; const deltaY = currentPoint.y - appState.actionStartPoint.y; const newWidth = Math.max(MIN_ELEMENT_WIDTH, appState.elementStartSize.width + deltaX); const newHeight = Math.max(MIN_ELEMENT_HEIGHT, appState.elementStartSize.height + deltaY); const newCenterX = newWidth / 2; const newCenterY = newHeight / 2; const rect = element.querySelector(".element-bg"); if (!rect) { console.error("Resize failed: No rect found."); return; } rect.setAttribute("width", String(newWidth)); rect.setAttribute("height", String(newHeight)); ensureHandles(element, newWidth, newHeight); const contentPaddingX = 10; const contentPaddingY = 30; const contentWidth = Math.max(0, newWidth - 2 * contentPaddingX); const contentHeight = Math.max(0, newHeight - contentPaddingY - 10); const foreignObject = element.querySelector("foreignObject"); const activitySvgContainer = element.querySelector(":scope > svg > svg"); if (foreignObject) { foreignObject.setAttribute("width", String(contentWidth)); foreignObject.setAttribute("height", String(contentHeight)); const innerContent = foreignObject.firstElementChild; if(innerContent) { innerContent.style.width = '100%'; innerContent.style.height = '100%'; const innerSvg = innerContent.querySelector('svg'); if(innerSvg){ innerSvg.style.width = '100%'; innerSvg.style.height = '100%'; } } } if (activitySvgContainer){ activitySvgContainer.setAttribute("width", String(contentWidth)); activitySvgContainer.setAttribute("height", String(contentHeight)); } translateTransform.setTranslate(appState.elementStartPos.x, appState.elementStartPos.y); let rotateTransform = null; for (let i = 0; i < transformList.numberOfItems; i++) { if (transformList.getItem(i).type === SVGTransform.SVG_TRANSFORM_ROTATE) { rotateTransform = transformList.getItem(i); break; } } if (rotateTransform) { rotateTransform.setRotate(rotateTransform.angle, newCenterX, newCenterY); } updateSelectionOutline(element); } }

        // (handleDocumentMouseUp - No changes needed from previous version)
        function handleDocumentMouseUp(event) { const wasDragging = appState.isDragging; const wasResizing = appState.isResizing; document.removeEventListener('mousemove', handleDocumentMouseMove, false); document.removeEventListener('mouseup', handleDocumentMouseUp, false); if (wasDragging || wasResizing) { appState.isDragging = false; appState.isResizing = false; } }

        // (svgPoint - No changes needed)
        function svgPoint(svgElement, clientX, clientY) { if (!svgElement) return null; const pt = svgElement.createSVGPoint(); pt.x = clientX; pt.y = clientY; try { const ctm = svgElement.getScreenCTM(); if (ctm?.inverse) { return pt.matrixTransform(ctm.inverse()); } else { console.warn("SVG CTM is null or not invertible."); const rect = svgElement.getBoundingClientRect(); const svgWidth = parseFloat(svgElement.getAttribute('width') || rect.width) || 1; const svgHeight = parseFloat(svgElement.getAttribute('height') || rect.height) || 1; pt.x = (clientX - rect.left) * (svgWidth / rect.width); pt.y = (clientY - rect.top) * (svgHeight / rect.height); return pt; } } catch (error) { console.error("Error getting/inverting CTM:", error); return null; } }


        // --- Drag and Drop Handling ---
        // (No changes needed)
        function handleActivityDragStart(event) { event.dataTransfer.setData("text/plain", event.target.dataset.activityId || ""); event.dataTransfer.setData("application/source", "activity"); event.dataTransfer.effectAllowed = "copy"; }
        function handleLibraryDragStart(event) { const itemElement = event.target.closest('.library-item'); if (!itemElement) return; event.dataTransfer.setData("text/plain", itemElement.dataset.svgName || ""); event.dataTransfer.setData("application/svg+xml", itemElement.dataset.svgContent || ""); event.dataTransfer.setData("application/source", "library"); event.dataTransfer.effectAllowed = "copy"; }
        function handleCanvasDragOver(event) { event.preventDefault(); event.dataTransfer.dropEffect = "copy"; }
        function handleCanvasDrop(event) { event.preventDefault(); const pt = svgPoint(dom.svgCanvas, event.clientX, event.clientY); if (!pt) { alert("Could not determine drop coordinates."); return; } const source = event.dataTransfer.getData("application/source"); const defaultWidth = 120, defaultHeight = 80; clearSelection(); if (source === "activity") { const activityId = event.dataTransfer.getData("text/plain"); const activity = appState.activities.find(a => String(a.id) === activityId); if (activity) { createCanvasElement({ type: 'activity', id: activity.id, name: activity.name, svgContent: activity.svg, width: defaultWidth, height: defaultHeight }, pt.x, pt.y); } else { console.warn("Dropped activity not found:", activityId); } } else if (source === "library") { const svgContent = event.dataTransfer.getData("application/svg+xml"); const svgName = event.dataTransfer.getData("text/plain"); if (svgContent) { let initialWidth = defaultWidth, initialHeight = defaultHeight; try { const parser = new DOMParser(); const svgDoc = parser.parseFromString(svgContent, "image/svg+xml"); const svgRoot = svgDoc.documentElement; if (svgRoot && svgRoot.nodeName === 'svg') { const vb = svgRoot.viewBox?.baseVal; const wAttr = svgRoot.getAttribute('width'); const hAttr = svgRoot.getAttribute('height'); if (vb && vb.width > 0 && vb.height > 0) { initialWidth = vb.width; initialHeight = vb.height; } else if (wAttr && hAttr) { initialWidth = parseFloat(wAttr) || initialWidth; initialHeight = parseFloat(hAttr) || initialHeight; } initialWidth = Math.min(Math.max(initialWidth, MIN_ELEMENT_WIDTH), 400); initialHeight = Math.min(Math.max(initialHeight, MIN_ELEMENT_HEIGHT), 400); } } catch (e) { console.error("Error parsing dropped SVG for size:", e); } createCanvasElement({ type: 'library', name: svgName || "Library SVG", svgContent: svgContent, width: initialWidth, height: initialHeight }, pt.x, pt.y); } else { console.warn("Dropped library item has no SVG content."); } } }

        // --- Save, Load, Export, Import ---
        // (ensureHandles - No changes needed)
        function ensureHandles(element, currentWidth, currentHeight) { if (!element) return; const transformList = element.transform.baseVal; const translate = getOrAddTransform(transformList, SVGTransform.SVG_TRANSFORM_TRANSLATE, 0, 0); const rect = element.querySelector('.element-bg'); const width = currentWidth ?? parseFloat(rect?.getAttribute('width') || String(MIN_ELEMENT_WIDTH)); const height = currentHeight ?? parseFloat(rect?.getAttribute('height') || String(MIN_ELEMENT_HEIGHT)); const centerX = width / 2; const centerY = height / 2; let currentRotation = 0; let rotateTransform = null; for (let i = 0; i < transformList.numberOfItems; i++) { if (transformList.getItem(i).type === SVGTransform.SVG_TRANSFORM_ROTATE) { rotateTransform = transformList.getItem(i); currentRotation = rotateTransform.angle; break; } } element.dataset.rotation = String(currentRotation); let resizeHandle = element.querySelector('.resize-handle'); if (!resizeHandle) { resizeHandle = document.createElementNS(SVG_NS, "circle"); resizeHandle.setAttribute("class", "resize-handle"); resizeHandle.setAttribute("r", String(RESIZE_HANDLE_RADIUS)); element.appendChild(resizeHandle); } resizeHandle.setAttribute("cx", String(width - RESIZE_HANDLE_OFFSET)); resizeHandle.setAttribute("cy", String(height - RESIZE_HANDLE_OFFSET)); /* Cursor set by CSS */ let moveHandle = element.querySelector('.move-handle'); const moveHandleWidth = width * MOVE_HANDLE_WIDTH_PERCENT; const moveHandleX = (width - moveHandleWidth) / 2; if (!moveHandle) { moveHandle = document.createElementNS(SVG_NS, "rect"); moveHandle.setAttribute("class", "move-handle"); moveHandle.setAttribute("height", String(MOVE_HANDLE_HEIGHT)); if (resizeHandle) { element.insertBefore(moveHandle, resizeHandle); } else { element.appendChild(moveHandle); } } moveHandle.setAttribute("x", String(moveHandleX)); moveHandle.setAttribute("y", String(MOVE_HANDLE_OFFSET)); moveHandle.setAttribute("width", String(moveHandleWidth)); /* Cursor set by CSS */ let rotateHandle = element.querySelector('.rotate-handle'); if (!rotateHandle) { rotateHandle = document.createElementNS(SVG_NS, "circle"); rotateHandle.setAttribute("class", "rotate-handle"); rotateHandle.setAttribute("r", String(ROTATE_HANDLE_RADIUS)); if (moveHandle) { element.insertBefore(rotateHandle, moveHandle.nextSibling); } else if (resizeHandle) { element.insertBefore(rotateHandle, resizeHandle); } else { element.appendChild(rotateHandle); } } rotateHandle.setAttribute("cx", String(centerX)); rotateHandle.setAttribute("cy", String(centerY)); /* Cursor set by CSS */ }

        // (saveDrawing, loadDrawing, exportDrawing, handleImportFileRead - No changes needed)
        function saveDrawing() { clearSelection(); localStorage.setItem("svgDrawing", dom.svgCanvas.innerHTML); alert("Drawing saved!"); }
        function loadDrawing() { const savedData = localStorage.getItem("svgDrawing"); if (savedData) { clearSelection(); dom.svgCanvas.innerHTML = savedData; dom.svgCanvas.querySelectorAll(".canvas-element").forEach(element => { ensureHandles(element); makeElementInteractive(element); }); alert("Drawing loaded!"); } else { alert("No saved drawing found!"); } }
        function exportDrawing() { clearSelection(); const svgExport = dom.svgCanvas.cloneNode(true); svgExport.querySelectorAll('.selected-outline, .resize-handle, .move-handle, .rotate-handle').forEach(el => el.remove()); svgExport.setAttribute("xmlns", SVG_NS); svgExport.setAttribute("version", "1.1"); const svgData = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n' + new XMLSerializer().serializeToString(svgExport); const blob = new Blob([svgData], { type: "image/svg+xml;charset=utf-8" }); const url = URL.createObjectURL(blob); const link = document.createElement("a"); link.href = url; link.download = "drawing.svg"; document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(url); }
        function handleImportFileRead(file) { const reader = new FileReader(); reader.onload = function(e) { try { const parser = new DOMParser(); const svgDoc = parser.parseFromString(e.target.result, "image/svg+xml"); const parseError = svgDoc.querySelector('parsererror'); if (!svgDoc.documentElement || svgDoc.documentElement.nodeName !== 'svg' || parseError) { throw new Error(`Invalid SVG file structure.${parseError ? ' ' + parseError.textContent : ''}`); } clearSelection(); dom.svgCanvas.innerHTML = ''; Array.from(svgDoc.documentElement.children).forEach(node => { const importedNode = document.importNode(node, true); if (importedNode.nodeType === Node.ELEMENT_NODE) { dom.svgCanvas.appendChild(importedNode); if (importedNode.classList?.contains('canvas-element')) { ensureHandles(importedNode); makeElementInteractive(importedNode); } } }); alert("SVG drawing imported successfully!"); } catch (error) { console.error("Import error:", error); alert(`Failed to import SVG: ${error.message}`); } }; reader.onerror = () => alert("Error reading file."); reader.readAsText(file); }

        // --- Initialization ---
        // MODIFIED: Call setActiveTool once at the end
        function init() {
            loadActivities();
            loadSvgLibrary();

            // Add Tool Button Listeners
            dom.toolButtons.forEach(button => {
                button.addEventListener('click', () => setActiveTool(button.dataset.tool));
            });
            // Add Canvas Drag/Drop Listeners
            dom.svgCanvas.addEventListener('dragover', handleCanvasDragOver);
            dom.svgCanvas.addEventListener('drop', handleCanvasDrop);
            // Add Canvas Click Listener (for clearing selection)
            dom.svgCanvas.addEventListener('click', (e) => {
                // Clear selection ONLY if clicking directly on the canvas background
                if (e.target === dom.svgCanvas) {
                    clearSelection();
                }
            });
            // Prevent canvas background mousedown from interfering (e.g., text selection)
            dom.svgCanvas.addEventListener('mousedown', (e) => {
                if (e.target === dom.svgCanvas) {
                    e.preventDefault();
                }
            });
            // Add Library Button/Input Listeners
            dom.addSvgBtn.addEventListener('click', () => dom.libraryInput.click());
            dom.libraryInput.addEventListener('change', (event) => { Array.from(event.target.files).forEach(handleLibraryFileRead); event.target.value = ''; });
            // Add Import/Export/Save/Load Button Listeners
            dom.importSvgButton.addEventListener('click', () => dom.fileInput.click());
            dom.fileInput.addEventListener('change', (event) => { if (event.target.files.length > 0) { handleImportFileRead(event.target.files[0]); } event.target.value = ''; });
            dom.saveButton.addEventListener('click', saveDrawing);
            dom.loadButton.addEventListener('click', loadDrawing);
            dom.exportSvgButton.addEventListener('click', exportDrawing);

            // Set initial tool state (which also applies body class)
            setActiveTool('select');
        }

        document.addEventListener("DOMContentLoaded", init);

    })();
</script>
</body>
</html>
